<html>
<head>
<title>prepare.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #7a7e85;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #2aacb8;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
prepare.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Prepares a distribution for installation 
&quot;&quot;&quot;</span>

<span class="s2"># The following comment should be removed at some point in the future.</span>
<span class="s2"># mypy: strict-optional=False</span>

<span class="s3">import </span><span class="s1">logging</span>
<span class="s3">import </span><span class="s1">mimetypes</span>
<span class="s3">import </span><span class="s1">os</span>
<span class="s3">import </span><span class="s1">shutil</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Dict</span><span class="s4">, </span><span class="s1">Iterable</span><span class="s4">, </span><span class="s1">List</span><span class="s4">, </span><span class="s1">Optional</span>

<span class="s3">from </span><span class="s1">pip</span><span class="s4">.</span><span class="s1">_vendor</span><span class="s4">.</span><span class="s1">packaging</span><span class="s4">.</span><span class="s1">utils </span><span class="s3">import </span><span class="s1">canonicalize_name</span>

<span class="s3">from </span><span class="s1">pip</span><span class="s4">.</span><span class="s1">_internal</span><span class="s4">.</span><span class="s1">distributions </span><span class="s3">import </span><span class="s1">make_distribution_for_install_requirement</span>
<span class="s3">from </span><span class="s1">pip</span><span class="s4">.</span><span class="s1">_internal</span><span class="s4">.</span><span class="s1">distributions</span><span class="s4">.</span><span class="s1">installed </span><span class="s3">import </span><span class="s1">InstalledDistribution</span>
<span class="s3">from </span><span class="s1">pip</span><span class="s4">.</span><span class="s1">_internal</span><span class="s4">.</span><span class="s1">exceptions </span><span class="s3">import </span><span class="s4">(</span>
    <span class="s1">DirectoryUrlHashUnsupported</span><span class="s4">,</span>
    <span class="s1">HashMismatch</span><span class="s4">,</span>
    <span class="s1">HashUnpinned</span><span class="s4">,</span>
    <span class="s1">InstallationError</span><span class="s4">,</span>
    <span class="s1">MetadataInconsistent</span><span class="s4">,</span>
    <span class="s1">NetworkConnectionError</span><span class="s4">,</span>
    <span class="s1">PreviousBuildDirError</span><span class="s4">,</span>
    <span class="s1">VcsHashUnsupported</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">from </span><span class="s1">pip</span><span class="s4">.</span><span class="s1">_internal</span><span class="s4">.</span><span class="s1">index</span><span class="s4">.</span><span class="s1">package_finder </span><span class="s3">import </span><span class="s1">PackageFinder</span>
<span class="s3">from </span><span class="s1">pip</span><span class="s4">.</span><span class="s1">_internal</span><span class="s4">.</span><span class="s1">metadata </span><span class="s3">import </span><span class="s1">BaseDistribution</span><span class="s4">, </span><span class="s1">get_metadata_distribution</span>
<span class="s3">from </span><span class="s1">pip</span><span class="s4">.</span><span class="s1">_internal</span><span class="s4">.</span><span class="s1">models</span><span class="s4">.</span><span class="s1">direct_url </span><span class="s3">import </span><span class="s1">ArchiveInfo</span>
<span class="s3">from </span><span class="s1">pip</span><span class="s4">.</span><span class="s1">_internal</span><span class="s4">.</span><span class="s1">models</span><span class="s4">.</span><span class="s1">link </span><span class="s3">import </span><span class="s1">Link</span>
<span class="s3">from </span><span class="s1">pip</span><span class="s4">.</span><span class="s1">_internal</span><span class="s4">.</span><span class="s1">models</span><span class="s4">.</span><span class="s1">wheel </span><span class="s3">import </span><span class="s1">Wheel</span>
<span class="s3">from </span><span class="s1">pip</span><span class="s4">.</span><span class="s1">_internal</span><span class="s4">.</span><span class="s1">network</span><span class="s4">.</span><span class="s1">download </span><span class="s3">import </span><span class="s1">BatchDownloader</span><span class="s4">, </span><span class="s1">Downloader</span>
<span class="s3">from </span><span class="s1">pip</span><span class="s4">.</span><span class="s1">_internal</span><span class="s4">.</span><span class="s1">network</span><span class="s4">.</span><span class="s1">lazy_wheel </span><span class="s3">import </span><span class="s4">(</span>
    <span class="s1">HTTPRangeRequestUnsupported</span><span class="s4">,</span>
    <span class="s1">dist_from_wheel_url</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">from </span><span class="s1">pip</span><span class="s4">.</span><span class="s1">_internal</span><span class="s4">.</span><span class="s1">network</span><span class="s4">.</span><span class="s1">session </span><span class="s3">import </span><span class="s1">PipSession</span>
<span class="s3">from </span><span class="s1">pip</span><span class="s4">.</span><span class="s1">_internal</span><span class="s4">.</span><span class="s1">operations</span><span class="s4">.</span><span class="s1">build</span><span class="s4">.</span><span class="s1">build_tracker </span><span class="s3">import </span><span class="s1">BuildTracker</span>
<span class="s3">from </span><span class="s1">pip</span><span class="s4">.</span><span class="s1">_internal</span><span class="s4">.</span><span class="s1">req</span><span class="s4">.</span><span class="s1">req_install </span><span class="s3">import </span><span class="s1">InstallRequirement</span>
<span class="s3">from </span><span class="s1">pip</span><span class="s4">.</span><span class="s1">_internal</span><span class="s4">.</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">direct_url_helpers </span><span class="s3">import </span><span class="s4">(</span>
    <span class="s1">direct_url_for_editable</span><span class="s4">,</span>
    <span class="s1">direct_url_from_link</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">from </span><span class="s1">pip</span><span class="s4">.</span><span class="s1">_internal</span><span class="s4">.</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">hashes </span><span class="s3">import </span><span class="s1">Hashes</span><span class="s4">, </span><span class="s1">MissingHashes</span>
<span class="s3">from </span><span class="s1">pip</span><span class="s4">.</span><span class="s1">_internal</span><span class="s4">.</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">logging </span><span class="s3">import </span><span class="s1">indent_log</span>
<span class="s3">from </span><span class="s1">pip</span><span class="s4">.</span><span class="s1">_internal</span><span class="s4">.</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">misc </span><span class="s3">import </span><span class="s4">(</span>
    <span class="s1">display_path</span><span class="s4">,</span>
    <span class="s1">hash_file</span><span class="s4">,</span>
    <span class="s1">hide_url</span><span class="s4">,</span>
    <span class="s1">is_installable_dir</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">from </span><span class="s1">pip</span><span class="s4">.</span><span class="s1">_internal</span><span class="s4">.</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">temp_dir </span><span class="s3">import </span><span class="s1">TempDirectory</span>
<span class="s3">from </span><span class="s1">pip</span><span class="s4">.</span><span class="s1">_internal</span><span class="s4">.</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">unpacking </span><span class="s3">import </span><span class="s1">unpack_file</span>
<span class="s3">from </span><span class="s1">pip</span><span class="s4">.</span><span class="s1">_internal</span><span class="s4">.</span><span class="s1">vcs </span><span class="s3">import </span><span class="s1">vcs</span>

<span class="s1">logger </span><span class="s4">= </span><span class="s1">logging</span><span class="s4">.</span><span class="s1">getLogger</span><span class="s4">(</span><span class="s1">__name__</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">_get_prepared_distribution</span><span class="s4">(</span>
    <span class="s1">req</span><span class="s4">: </span><span class="s1">InstallRequirement</span><span class="s4">,</span>
    <span class="s1">build_tracker</span><span class="s4">: </span><span class="s1">BuildTracker</span><span class="s4">,</span>
    <span class="s1">finder</span><span class="s4">: </span><span class="s1">PackageFinder</span><span class="s4">,</span>
    <span class="s1">build_isolation</span><span class="s4">: </span><span class="s1">bool</span><span class="s4">,</span>
    <span class="s1">check_build_deps</span><span class="s4">: </span><span class="s1">bool</span><span class="s4">,</span>
<span class="s4">) </span><span class="s1">-&gt; BaseDistribution</span><span class="s4">:</span>
    <span class="s0">&quot;&quot;&quot;Prepare a distribution for installation.&quot;&quot;&quot;</span>
    <span class="s1">abstract_dist </span><span class="s4">= </span><span class="s1">make_distribution_for_install_requirement</span><span class="s4">(</span><span class="s1">req</span><span class="s4">)</span>
    <span class="s3">with </span><span class="s1">build_tracker</span><span class="s4">.</span><span class="s1">track</span><span class="s4">(</span><span class="s1">req</span><span class="s4">):</span>
        <span class="s1">abstract_dist</span><span class="s4">.</span><span class="s1">prepare_distribution_metadata</span><span class="s4">(</span>
            <span class="s1">finder</span><span class="s4">, </span><span class="s1">build_isolation</span><span class="s4">, </span><span class="s1">check_build_deps</span>
        <span class="s4">)</span>
    <span class="s3">return </span><span class="s1">abstract_dist</span><span class="s4">.</span><span class="s1">get_metadata_distribution</span><span class="s4">()</span>


<span class="s3">def </span><span class="s1">unpack_vcs_link</span><span class="s4">(</span><span class="s1">link</span><span class="s4">: </span><span class="s1">Link</span><span class="s4">, </span><span class="s1">location</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">verbosity</span><span class="s4">: </span><span class="s1">int</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
    <span class="s1">vcs_backend </span><span class="s4">= </span><span class="s1">vcs</span><span class="s4">.</span><span class="s1">get_backend_for_scheme</span><span class="s4">(</span><span class="s1">link</span><span class="s4">.</span><span class="s1">scheme</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">vcs_backend </span><span class="s3">is not None</span>
    <span class="s1">vcs_backend</span><span class="s4">.</span><span class="s1">unpack</span><span class="s4">(</span><span class="s1">location</span><span class="s4">, </span><span class="s1">url</span><span class="s4">=</span><span class="s1">hide_url</span><span class="s4">(</span><span class="s1">link</span><span class="s4">.</span><span class="s1">url</span><span class="s4">), </span><span class="s1">verbosity</span><span class="s4">=</span><span class="s1">verbosity</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">File</span><span class="s4">:</span>
    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">path</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">content_type</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">path </span><span class="s4">= </span><span class="s1">path</span>
        <span class="s3">if </span><span class="s1">content_type </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">content_type </span><span class="s4">= </span><span class="s1">mimetypes</span><span class="s4">.</span><span class="s1">guess_type</span><span class="s4">(</span><span class="s1">path</span><span class="s4">)[</span><span class="s5">0</span><span class="s4">]</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">content_type </span><span class="s4">= </span><span class="s1">content_type</span>


<span class="s3">def </span><span class="s1">get_http_url</span><span class="s4">(</span>
    <span class="s1">link</span><span class="s4">: </span><span class="s1">Link</span><span class="s4">,</span>
    <span class="s1">download</span><span class="s4">: </span><span class="s1">Downloader</span><span class="s4">,</span>
    <span class="s1">download_dir</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">hashes</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Hashes</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
<span class="s4">) </span><span class="s1">-&gt; File</span><span class="s4">:</span>
    <span class="s1">temp_dir </span><span class="s4">= </span><span class="s1">TempDirectory</span><span class="s4">(</span><span class="s1">kind</span><span class="s4">=</span><span class="s6">&quot;unpack&quot;</span><span class="s4">, </span><span class="s1">globally_managed</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
    <span class="s2"># If a download dir is specified, is the file already downloaded there?</span>
    <span class="s1">already_downloaded_path </span><span class="s4">= </span><span class="s3">None</span>
    <span class="s3">if </span><span class="s1">download_dir</span><span class="s4">:</span>
        <span class="s1">already_downloaded_path </span><span class="s4">= </span><span class="s1">_check_download_dir</span><span class="s4">(</span><span class="s1">link</span><span class="s4">, </span><span class="s1">download_dir</span><span class="s4">, </span><span class="s1">hashes</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">already_downloaded_path</span><span class="s4">:</span>
        <span class="s1">from_path </span><span class="s4">= </span><span class="s1">already_downloaded_path</span>
        <span class="s1">content_type </span><span class="s4">= </span><span class="s3">None</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s2"># let's download to a tmp dir</span>
        <span class="s1">from_path</span><span class="s4">, </span><span class="s1">content_type </span><span class="s4">= </span><span class="s1">download</span><span class="s4">(</span><span class="s1">link</span><span class="s4">, </span><span class="s1">temp_dir</span><span class="s4">.</span><span class="s1">path</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">hashes</span><span class="s4">:</span>
            <span class="s1">hashes</span><span class="s4">.</span><span class="s1">check_against_path</span><span class="s4">(</span><span class="s1">from_path</span><span class="s4">)</span>

    <span class="s3">return </span><span class="s1">File</span><span class="s4">(</span><span class="s1">from_path</span><span class="s4">, </span><span class="s1">content_type</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">get_file_url</span><span class="s4">(</span>
    <span class="s1">link</span><span class="s4">: </span><span class="s1">Link</span><span class="s4">, </span><span class="s1">download_dir</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">, </span><span class="s1">hashes</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Hashes</span><span class="s4">] = </span><span class="s3">None</span>
<span class="s4">) </span><span class="s1">-&gt; File</span><span class="s4">:</span>
    <span class="s0">&quot;&quot;&quot;Get file and optionally check its hash.&quot;&quot;&quot;</span>
    <span class="s2"># If a download dir is specified, is the file already there and valid?</span>
    <span class="s1">already_downloaded_path </span><span class="s4">= </span><span class="s3">None</span>
    <span class="s3">if </span><span class="s1">download_dir</span><span class="s4">:</span>
        <span class="s1">already_downloaded_path </span><span class="s4">= </span><span class="s1">_check_download_dir</span><span class="s4">(</span><span class="s1">link</span><span class="s4">, </span><span class="s1">download_dir</span><span class="s4">, </span><span class="s1">hashes</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">already_downloaded_path</span><span class="s4">:</span>
        <span class="s1">from_path </span><span class="s4">= </span><span class="s1">already_downloaded_path</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">from_path </span><span class="s4">= </span><span class="s1">link</span><span class="s4">.</span><span class="s1">file_path</span>

    <span class="s2"># If --require-hashes is off, `hashes` is either empty, the</span>
    <span class="s2"># link's embedded hash, or MissingHashes; it is required to</span>
    <span class="s2"># match. If --require-hashes is on, we are satisfied by any</span>
    <span class="s2"># hash in `hashes` matching: a URL-based or an option-based</span>
    <span class="s2"># one; no internet-sourced hash will be in `hashes`.</span>
    <span class="s3">if </span><span class="s1">hashes</span><span class="s4">:</span>
        <span class="s1">hashes</span><span class="s4">.</span><span class="s1">check_against_path</span><span class="s4">(</span><span class="s1">from_path</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">File</span><span class="s4">(</span><span class="s1">from_path</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">unpack_url</span><span class="s4">(</span>
    <span class="s1">link</span><span class="s4">: </span><span class="s1">Link</span><span class="s4">,</span>
    <span class="s1">location</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
    <span class="s1">download</span><span class="s4">: </span><span class="s1">Downloader</span><span class="s4">,</span>
    <span class="s1">verbosity</span><span class="s4">: </span><span class="s1">int</span><span class="s4">,</span>
    <span class="s1">download_dir</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">hashes</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Hashes</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
<span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">File</span><span class="s4">]:</span>
    <span class="s0">&quot;&quot;&quot;Unpack link into location, downloading if required. 
 
    :param hashes: A Hashes object, one of whose embedded hashes must match, 
        or HashMismatch will be raised. If the Hashes is empty, no matches are 
        required, and unhashable types of requirements (like VCS ones, which 
        would ordinarily raise HashUnsupported) are allowed. 
    &quot;&quot;&quot;</span>
    <span class="s2"># non-editable vcs urls</span>
    <span class="s3">if </span><span class="s1">link</span><span class="s4">.</span><span class="s1">is_vcs</span><span class="s4">:</span>
        <span class="s1">unpack_vcs_link</span><span class="s4">(</span><span class="s1">link</span><span class="s4">, </span><span class="s1">location</span><span class="s4">, </span><span class="s1">verbosity</span><span class="s4">=</span><span class="s1">verbosity</span><span class="s4">)</span>
        <span class="s3">return None</span>

    <span class="s3">assert not </span><span class="s1">link</span><span class="s4">.</span><span class="s1">is_existing_dir</span><span class="s4">()</span>

    <span class="s2"># file urls</span>
    <span class="s3">if </span><span class="s1">link</span><span class="s4">.</span><span class="s1">is_file</span><span class="s4">:</span>
        <span class="s1">file </span><span class="s4">= </span><span class="s1">get_file_url</span><span class="s4">(</span><span class="s1">link</span><span class="s4">, </span><span class="s1">download_dir</span><span class="s4">, </span><span class="s1">hashes</span><span class="s4">=</span><span class="s1">hashes</span><span class="s4">)</span>

    <span class="s2"># http urls</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">file </span><span class="s4">= </span><span class="s1">get_http_url</span><span class="s4">(</span>
            <span class="s1">link</span><span class="s4">,</span>
            <span class="s1">download</span><span class="s4">,</span>
            <span class="s1">download_dir</span><span class="s4">,</span>
            <span class="s1">hashes</span><span class="s4">=</span><span class="s1">hashes</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s2"># unpack the archive to the build dir location. even when only downloading</span>
    <span class="s2"># archives, they have to be unpacked to parse dependencies, except wheels</span>
    <span class="s3">if not </span><span class="s1">link</span><span class="s4">.</span><span class="s1">is_wheel</span><span class="s4">:</span>
        <span class="s1">unpack_file</span><span class="s4">(</span><span class="s1">file</span><span class="s4">.</span><span class="s1">path</span><span class="s4">, </span><span class="s1">location</span><span class="s4">, </span><span class="s1">file</span><span class="s4">.</span><span class="s1">content_type</span><span class="s4">)</span>

    <span class="s3">return </span><span class="s1">file</span>


<span class="s3">def </span><span class="s1">_check_download_dir</span><span class="s4">(</span>
    <span class="s1">link</span><span class="s4">: </span><span class="s1">Link</span><span class="s4">,</span>
    <span class="s1">download_dir</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
    <span class="s1">hashes</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Hashes</span><span class="s4">],</span>
    <span class="s1">warn_on_hash_mismatch</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">,</span>
<span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]:</span>
    <span class="s0">&quot;&quot;&quot;Check download_dir for previously downloaded file with correct hash 
    If a correct file is found return its path else None 
    &quot;&quot;&quot;</span>
    <span class="s1">download_path </span><span class="s4">= </span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">download_dir</span><span class="s4">, </span><span class="s1">link</span><span class="s4">.</span><span class="s1">filename</span><span class="s4">)</span>

    <span class="s3">if not </span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">exists</span><span class="s4">(</span><span class="s1">download_path</span><span class="s4">):</span>
        <span class="s3">return None</span>

    <span class="s2"># If already downloaded, does its hash match?</span>
    <span class="s1">logger</span><span class="s4">.</span><span class="s1">info</span><span class="s4">(</span><span class="s6">&quot;File was already downloaded %s&quot;</span><span class="s4">, </span><span class="s1">download_path</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">hashes</span><span class="s4">:</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">hashes</span><span class="s4">.</span><span class="s1">check_against_path</span><span class="s4">(</span><span class="s1">download_path</span><span class="s4">)</span>
        <span class="s3">except </span><span class="s1">HashMismatch</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">warn_on_hash_mismatch</span><span class="s4">:</span>
                <span class="s1">logger</span><span class="s4">.</span><span class="s1">warning</span><span class="s4">(</span>
                    <span class="s6">&quot;Previously-downloaded file %s has bad hash. Re-downloading.&quot;</span><span class="s4">,</span>
                    <span class="s1">download_path</span><span class="s4">,</span>
                <span class="s4">)</span>
            <span class="s1">os</span><span class="s4">.</span><span class="s1">unlink</span><span class="s4">(</span><span class="s1">download_path</span><span class="s4">)</span>
            <span class="s3">return None</span>
    <span class="s3">return </span><span class="s1">download_path</span>


<span class="s3">class </span><span class="s1">RequirementPreparer</span><span class="s4">:</span>
    <span class="s0">&quot;&quot;&quot;Prepares a Requirement&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">build_dir</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
        <span class="s1">download_dir</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">],</span>
        <span class="s1">src_dir</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
        <span class="s1">build_isolation</span><span class="s4">: </span><span class="s1">bool</span><span class="s4">,</span>
        <span class="s1">check_build_deps</span><span class="s4">: </span><span class="s1">bool</span><span class="s4">,</span>
        <span class="s1">build_tracker</span><span class="s4">: </span><span class="s1">BuildTracker</span><span class="s4">,</span>
        <span class="s1">session</span><span class="s4">: </span><span class="s1">PipSession</span><span class="s4">,</span>
        <span class="s1">progress_bar</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
        <span class="s1">finder</span><span class="s4">: </span><span class="s1">PackageFinder</span><span class="s4">,</span>
        <span class="s1">require_hashes</span><span class="s4">: </span><span class="s1">bool</span><span class="s4">,</span>
        <span class="s1">use_user_site</span><span class="s4">: </span><span class="s1">bool</span><span class="s4">,</span>
        <span class="s1">lazy_wheel</span><span class="s4">: </span><span class="s1">bool</span><span class="s4">,</span>
        <span class="s1">verbosity</span><span class="s4">: </span><span class="s1">int</span><span class="s4">,</span>
        <span class="s1">legacy_resolver</span><span class="s4">: </span><span class="s1">bool</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">()</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">src_dir </span><span class="s4">= </span><span class="s1">src_dir</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">build_dir </span><span class="s4">= </span><span class="s1">build_dir</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">build_tracker </span><span class="s4">= </span><span class="s1">build_tracker</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_session </span><span class="s4">= </span><span class="s1">session</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_download </span><span class="s4">= </span><span class="s1">Downloader</span><span class="s4">(</span><span class="s1">session</span><span class="s4">, </span><span class="s1">progress_bar</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_batch_download </span><span class="s4">= </span><span class="s1">BatchDownloader</span><span class="s4">(</span><span class="s1">session</span><span class="s4">, </span><span class="s1">progress_bar</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">finder </span><span class="s4">= </span><span class="s1">finder</span>

        <span class="s2"># Where still-packed archives should be written to. If None, they are</span>
        <span class="s2"># not saved, and are deleted immediately after unpacking.</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">download_dir </span><span class="s4">= </span><span class="s1">download_dir</span>

        <span class="s2"># Is build isolation allowed?</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">build_isolation </span><span class="s4">= </span><span class="s1">build_isolation</span>

        <span class="s2"># Should check build dependencies?</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">check_build_deps </span><span class="s4">= </span><span class="s1">check_build_deps</span>

        <span class="s2"># Should hash-checking be required?</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">require_hashes </span><span class="s4">= </span><span class="s1">require_hashes</span>

        <span class="s2"># Should install in user site-packages?</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">use_user_site </span><span class="s4">= </span><span class="s1">use_user_site</span>

        <span class="s2"># Should wheels be downloaded lazily?</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">use_lazy_wheel </span><span class="s4">= </span><span class="s1">lazy_wheel</span>

        <span class="s2"># How verbose should underlying tooling be?</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">verbosity </span><span class="s4">= </span><span class="s1">verbosity</span>

        <span class="s2"># Are we using the legacy resolver?</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">legacy_resolver </span><span class="s4">= </span><span class="s1">legacy_resolver</span>

        <span class="s2"># Memoized downloaded files, as mapping of url: path.</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_downloaded</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">str</span><span class="s4">] = {}</span>

        <span class="s2"># Previous &quot;header&quot; printed for a link-based InstallRequirement</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_previous_requirement_header </span><span class="s4">= (</span><span class="s6">&quot;&quot;</span><span class="s4">, </span><span class="s6">&quot;&quot;</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_log_preparing_link</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">req</span><span class="s4">: </span><span class="s1">InstallRequirement</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s0">&quot;&quot;&quot;Provide context for the requirement being prepared.&quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">req</span><span class="s4">.</span><span class="s1">link</span><span class="s4">.</span><span class="s1">is_file </span><span class="s3">and not </span><span class="s1">req</span><span class="s4">.</span><span class="s1">is_wheel_from_cache</span><span class="s4">:</span>
            <span class="s1">message </span><span class="s4">= </span><span class="s6">&quot;Processing %s&quot;</span>
            <span class="s1">information </span><span class="s4">= </span><span class="s1">str</span><span class="s4">(</span><span class="s1">display_path</span><span class="s4">(</span><span class="s1">req</span><span class="s4">.</span><span class="s1">link</span><span class="s4">.</span><span class="s1">file_path</span><span class="s4">))</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">message </span><span class="s4">= </span><span class="s6">&quot;Collecting %s&quot;</span>
            <span class="s1">information </span><span class="s4">= </span><span class="s1">str</span><span class="s4">(</span><span class="s1">req</span><span class="s4">.</span><span class="s1">req </span><span class="s3">or </span><span class="s1">req</span><span class="s4">)</span>

        <span class="s2"># If we used req.req, inject requirement source if available (this</span>
        <span class="s2"># would already be included if we used req directly)</span>
        <span class="s3">if </span><span class="s1">req</span><span class="s4">.</span><span class="s1">req </span><span class="s3">and </span><span class="s1">req</span><span class="s4">.</span><span class="s1">comes_from</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">req</span><span class="s4">.</span><span class="s1">comes_from</span><span class="s4">, </span><span class="s1">str</span><span class="s4">):</span>
                <span class="s1">comes_from</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s1">req</span><span class="s4">.</span><span class="s1">comes_from</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">comes_from </span><span class="s4">= </span><span class="s1">req</span><span class="s4">.</span><span class="s1">comes_from</span><span class="s4">.</span><span class="s1">from_path</span><span class="s4">()</span>
            <span class="s3">if </span><span class="s1">comes_from</span><span class="s4">:</span>
                <span class="s1">information </span><span class="s4">+= </span><span class="s6">f&quot; (from </span><span class="s3">{</span><span class="s1">comes_from</span><span class="s3">}</span><span class="s6">)&quot;</span>

        <span class="s3">if </span><span class="s4">(</span><span class="s1">message</span><span class="s4">, </span><span class="s1">information</span><span class="s4">) != </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_previous_requirement_header</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_previous_requirement_header </span><span class="s4">= (</span><span class="s1">message</span><span class="s4">, </span><span class="s1">information</span><span class="s4">)</span>
            <span class="s1">logger</span><span class="s4">.</span><span class="s1">info</span><span class="s4">(</span><span class="s1">message</span><span class="s4">, </span><span class="s1">information</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">req</span><span class="s4">.</span><span class="s1">is_wheel_from_cache</span><span class="s4">:</span>
            <span class="s3">with </span><span class="s1">indent_log</span><span class="s4">():</span>
                <span class="s1">logger</span><span class="s4">.</span><span class="s1">info</span><span class="s4">(</span><span class="s6">&quot;Using cached %s&quot;</span><span class="s4">, </span><span class="s1">req</span><span class="s4">.</span><span class="s1">link</span><span class="s4">.</span><span class="s1">filename</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_ensure_link_req_src_dir</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">req</span><span class="s4">: </span><span class="s1">InstallRequirement</span><span class="s4">, </span><span class="s1">parallel_builds</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s0">&quot;&quot;&quot;Ensure source_dir of a linked InstallRequirement.&quot;&quot;&quot;</span>
        <span class="s2"># Since source_dir is only set for editable requirements.</span>
        <span class="s3">if </span><span class="s1">req</span><span class="s4">.</span><span class="s1">link</span><span class="s4">.</span><span class="s1">is_wheel</span><span class="s4">:</span>
            <span class="s2"># We don't need to unpack wheels, so no need for a source</span>
            <span class="s2"># directory.</span>
            <span class="s3">return</span>
        <span class="s3">assert </span><span class="s1">req</span><span class="s4">.</span><span class="s1">source_dir </span><span class="s3">is None</span>
        <span class="s3">if </span><span class="s1">req</span><span class="s4">.</span><span class="s1">link</span><span class="s4">.</span><span class="s1">is_existing_dir</span><span class="s4">():</span>
            <span class="s2"># build local directories in-tree</span>
            <span class="s1">req</span><span class="s4">.</span><span class="s1">source_dir </span><span class="s4">= </span><span class="s1">req</span><span class="s4">.</span><span class="s1">link</span><span class="s4">.</span><span class="s1">file_path</span>
            <span class="s3">return</span>

        <span class="s2"># We always delete unpacked sdists after pip runs.</span>
        <span class="s1">req</span><span class="s4">.</span><span class="s1">ensure_has_source_dir</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">build_dir</span><span class="s4">,</span>
            <span class="s1">autodelete</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
            <span class="s1">parallel_builds</span><span class="s4">=</span><span class="s1">parallel_builds</span><span class="s4">,</span>
        <span class="s4">)</span>

        <span class="s2"># If a checkout exists, it's unwise to keep going.  version</span>
        <span class="s2"># inconsistencies are logged later, but do not fail the</span>
        <span class="s2"># installation.</span>
        <span class="s2"># FIXME: this won't upgrade when there's an existing</span>
        <span class="s2"># package unpacked in `req.source_dir`</span>
        <span class="s2"># TODO: this check is now probably dead code</span>
        <span class="s3">if </span><span class="s1">is_installable_dir</span><span class="s4">(</span><span class="s1">req</span><span class="s4">.</span><span class="s1">source_dir</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">PreviousBuildDirError</span><span class="s4">(</span>
                <span class="s6">&quot;pip can't proceed with requirements '{}' due to a&quot;</span>
                <span class="s6">&quot;pre-existing build directory ({}). This is likely &quot;</span>
                <span class="s6">&quot;due to a previous installation that failed . pip is &quot;</span>
                <span class="s6">&quot;being responsible and not assuming it can delete this. &quot;</span>
                <span class="s6">&quot;Please delete it and try again.&quot;</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span><span class="s1">req</span><span class="s4">, </span><span class="s1">req</span><span class="s4">.</span><span class="s1">source_dir</span><span class="s4">)</span>
            <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_get_linked_req_hashes</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">req</span><span class="s4">: </span><span class="s1">InstallRequirement</span><span class="s4">) </span><span class="s1">-&gt; Hashes</span><span class="s4">:</span>
        <span class="s2"># By the time this is called, the requirement's link should have</span>
        <span class="s2"># been checked so we can tell what kind of requirements req is</span>
        <span class="s2"># and raise some more informative errors than otherwise.</span>
        <span class="s2"># (For example, we can raise VcsHashUnsupported for a VCS URL</span>
        <span class="s2"># rather than HashMissing.)</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">require_hashes</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">req</span><span class="s4">.</span><span class="s1">hashes</span><span class="s4">(</span><span class="s1">trust_internet</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>

        <span class="s2"># We could check these first 2 conditions inside unpack_url</span>
        <span class="s2"># and save repetition of conditions, but then we would</span>
        <span class="s2"># report less-useful error messages for unhashable</span>
        <span class="s2"># requirements, complaining that there's no hash provided.</span>
        <span class="s3">if </span><span class="s1">req</span><span class="s4">.</span><span class="s1">link</span><span class="s4">.</span><span class="s1">is_vcs</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">VcsHashUnsupported</span><span class="s4">()</span>
        <span class="s3">if </span><span class="s1">req</span><span class="s4">.</span><span class="s1">link</span><span class="s4">.</span><span class="s1">is_existing_dir</span><span class="s4">():</span>
            <span class="s3">raise </span><span class="s1">DirectoryUrlHashUnsupported</span><span class="s4">()</span>

        <span class="s2"># Unpinned packages are asking for trouble when a new version</span>
        <span class="s2"># is uploaded.  This isn't a security check, but it saves users</span>
        <span class="s2"># a surprising hash mismatch in the future.</span>
        <span class="s2"># file:/// URLs aren't pinnable, so don't complain about them</span>
        <span class="s2"># not being pinned.</span>
        <span class="s3">if not </span><span class="s1">req</span><span class="s4">.</span><span class="s1">is_direct </span><span class="s3">and not </span><span class="s1">req</span><span class="s4">.</span><span class="s1">is_pinned</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">HashUnpinned</span><span class="s4">()</span>

        <span class="s2"># If known-good hashes are missing for this requirement,</span>
        <span class="s2"># shim it with a facade object that will provoke hash</span>
        <span class="s2"># computation and then raise a HashMissing exception</span>
        <span class="s2"># showing the user what the hash should be.</span>
        <span class="s3">return </span><span class="s1">req</span><span class="s4">.</span><span class="s1">hashes</span><span class="s4">(</span><span class="s1">trust_internet</span><span class="s4">=</span><span class="s3">False</span><span class="s4">) </span><span class="s3">or </span><span class="s1">MissingHashes</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">_fetch_metadata_only</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">req</span><span class="s4">: </span><span class="s1">InstallRequirement</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">BaseDistribution</span><span class="s4">]:</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">legacy_resolver</span><span class="s4">:</span>
            <span class="s1">logger</span><span class="s4">.</span><span class="s1">debug</span><span class="s4">(</span>
                <span class="s6">&quot;Metadata-only fetching is not used in the legacy resolver&quot;</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s3">return None</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">require_hashes</span><span class="s4">:</span>
            <span class="s1">logger</span><span class="s4">.</span><span class="s1">debug</span><span class="s4">(</span>
                <span class="s6">&quot;Metadata-only fetching is not used as hash checking is required&quot;</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s3">return None</span>
        <span class="s2"># Try PEP 658 metadata first, then fall back to lazy wheel if unavailable.</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_fetch_metadata_using_link_data_attr</span><span class="s4">(</span>
            <span class="s1">req</span>
        <span class="s4">) </span><span class="s3">or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_fetch_metadata_using_lazy_wheel</span><span class="s4">(</span><span class="s1">req</span><span class="s4">.</span><span class="s1">link</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_fetch_metadata_using_link_data_attr</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">req</span><span class="s4">: </span><span class="s1">InstallRequirement</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">BaseDistribution</span><span class="s4">]:</span>
        <span class="s0">&quot;&quot;&quot;Fetch metadata from the data-dist-info-metadata attribute, if possible.&quot;&quot;&quot;</span>
        <span class="s2"># (1) Get the link to the metadata file, if provided by the backend.</span>
        <span class="s1">metadata_link </span><span class="s4">= </span><span class="s1">req</span><span class="s4">.</span><span class="s1">link</span><span class="s4">.</span><span class="s1">metadata_link</span><span class="s4">()</span>
        <span class="s3">if </span><span class="s1">metadata_link </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">return None</span>
        <span class="s3">assert </span><span class="s1">req</span><span class="s4">.</span><span class="s1">req </span><span class="s3">is not None</span>
        <span class="s1">logger</span><span class="s4">.</span><span class="s1">info</span><span class="s4">(</span>
            <span class="s6">&quot;Obtaining dependency information for %s from %s&quot;</span><span class="s4">,</span>
            <span class="s1">req</span><span class="s4">.</span><span class="s1">req</span><span class="s4">,</span>
            <span class="s1">metadata_link</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s2"># (2) Download the contents of the METADATA file, separate from the dist itself.</span>
        <span class="s1">metadata_file </span><span class="s4">= </span><span class="s1">get_http_url</span><span class="s4">(</span>
            <span class="s1">metadata_link</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_download</span><span class="s4">,</span>
            <span class="s1">hashes</span><span class="s4">=</span><span class="s1">metadata_link</span><span class="s4">.</span><span class="s1">as_hashes</span><span class="s4">(),</span>
        <span class="s4">)</span>
        <span class="s3">with </span><span class="s1">open</span><span class="s4">(</span><span class="s1">metadata_file</span><span class="s4">.</span><span class="s1">path</span><span class="s4">, </span><span class="s6">&quot;rb&quot;</span><span class="s4">) </span><span class="s3">as </span><span class="s1">f</span><span class="s4">:</span>
            <span class="s1">metadata_contents </span><span class="s4">= </span><span class="s1">f</span><span class="s4">.</span><span class="s1">read</span><span class="s4">()</span>
        <span class="s2"># (3) Generate a dist just from those file contents.</span>
        <span class="s1">metadata_dist </span><span class="s4">= </span><span class="s1">get_metadata_distribution</span><span class="s4">(</span>
            <span class="s1">metadata_contents</span><span class="s4">,</span>
            <span class="s1">req</span><span class="s4">.</span><span class="s1">link</span><span class="s4">.</span><span class="s1">filename</span><span class="s4">,</span>
            <span class="s1">req</span><span class="s4">.</span><span class="s1">req</span><span class="s4">.</span><span class="s1">name</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s2"># (4) Ensure the Name: field from the METADATA file matches the name from the</span>
        <span class="s2">#     install requirement.</span>
        <span class="s2">#</span>
        <span class="s2">#     NB: raw_name will fall back to the name from the install requirement if</span>
        <span class="s2">#     the Name: field is not present, but it's noted in the raw_name docstring</span>
        <span class="s2">#     that that should NEVER happen anyway.</span>
        <span class="s3">if </span><span class="s1">canonicalize_name</span><span class="s4">(</span><span class="s1">metadata_dist</span><span class="s4">.</span><span class="s1">raw_name</span><span class="s4">) != </span><span class="s1">canonicalize_name</span><span class="s4">(</span><span class="s1">req</span><span class="s4">.</span><span class="s1">req</span><span class="s4">.</span><span class="s1">name</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">MetadataInconsistent</span><span class="s4">(</span>
                <span class="s1">req</span><span class="s4">, </span><span class="s6">&quot;Name&quot;</span><span class="s4">, </span><span class="s1">req</span><span class="s4">.</span><span class="s1">req</span><span class="s4">.</span><span class="s1">name</span><span class="s4">, </span><span class="s1">metadata_dist</span><span class="s4">.</span><span class="s1">raw_name</span>
            <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">metadata_dist</span>

    <span class="s3">def </span><span class="s1">_fetch_metadata_using_lazy_wheel</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">link</span><span class="s4">: </span><span class="s1">Link</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">BaseDistribution</span><span class="s4">]:</span>
        <span class="s0">&quot;&quot;&quot;Fetch metadata using lazy wheel, if possible.&quot;&quot;&quot;</span>
        <span class="s2"># --use-feature=fast-deps must be provided.</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">use_lazy_wheel</span><span class="s4">:</span>
            <span class="s3">return None</span>
        <span class="s3">if </span><span class="s1">link</span><span class="s4">.</span><span class="s1">is_file </span><span class="s3">or not </span><span class="s1">link</span><span class="s4">.</span><span class="s1">is_wheel</span><span class="s4">:</span>
            <span class="s1">logger</span><span class="s4">.</span><span class="s1">debug</span><span class="s4">(</span>
                <span class="s6">&quot;Lazy wheel is not used as %r does not point to a remote wheel&quot;</span><span class="s4">,</span>
                <span class="s1">link</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s3">return None</span>

        <span class="s1">wheel </span><span class="s4">= </span><span class="s1">Wheel</span><span class="s4">(</span><span class="s1">link</span><span class="s4">.</span><span class="s1">filename</span><span class="s4">)</span>
        <span class="s1">name </span><span class="s4">= </span><span class="s1">canonicalize_name</span><span class="s4">(</span><span class="s1">wheel</span><span class="s4">.</span><span class="s1">name</span><span class="s4">)</span>
        <span class="s1">logger</span><span class="s4">.</span><span class="s1">info</span><span class="s4">(</span>
            <span class="s6">&quot;Obtaining dependency information from %s %s&quot;</span><span class="s4">,</span>
            <span class="s1">name</span><span class="s4">,</span>
            <span class="s1">wheel</span><span class="s4">.</span><span class="s1">version</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s1">url </span><span class="s4">= </span><span class="s1">link</span><span class="s4">.</span><span class="s1">url</span><span class="s4">.</span><span class="s1">split</span><span class="s4">(</span><span class="s6">&quot;#&quot;</span><span class="s4">, </span><span class="s5">1</span><span class="s4">)[</span><span class="s5">0</span><span class="s4">]</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">dist_from_wheel_url</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">url</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_session</span><span class="s4">)</span>
        <span class="s3">except </span><span class="s1">HTTPRangeRequestUnsupported</span><span class="s4">:</span>
            <span class="s1">logger</span><span class="s4">.</span><span class="s1">debug</span><span class="s4">(</span><span class="s6">&quot;%s does not support range requests&quot;</span><span class="s4">, </span><span class="s1">url</span><span class="s4">)</span>
            <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">_complete_partial_requirements</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">partially_downloaded_reqs</span><span class="s4">: </span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">InstallRequirement</span><span class="s4">],</span>
        <span class="s1">parallel_builds</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s0">&quot;&quot;&quot;Download any requirements which were only fetched by metadata.&quot;&quot;&quot;</span>
        <span class="s2"># Download to a temporary directory. These will be copied over as</span>
        <span class="s2"># needed for downstream 'download', 'wheel', and 'install' commands.</span>
        <span class="s1">temp_dir </span><span class="s4">= </span><span class="s1">TempDirectory</span><span class="s4">(</span><span class="s1">kind</span><span class="s4">=</span><span class="s6">&quot;unpack&quot;</span><span class="s4">, </span><span class="s1">globally_managed</span><span class="s4">=</span><span class="s3">True</span><span class="s4">).</span><span class="s1">path</span>

        <span class="s2"># Map each link to the requirement that owns it. This allows us to set</span>
        <span class="s2"># `req.local_file_path` on the appropriate requirement after passing</span>
        <span class="s2"># all the links at once into BatchDownloader.</span>
        <span class="s1">links_to_fully_download</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">Link</span><span class="s4">, </span><span class="s1">InstallRequirement</span><span class="s4">] = {}</span>
        <span class="s3">for </span><span class="s1">req </span><span class="s3">in </span><span class="s1">partially_downloaded_reqs</span><span class="s4">:</span>
            <span class="s3">assert </span><span class="s1">req</span><span class="s4">.</span><span class="s1">link</span>
            <span class="s1">links_to_fully_download</span><span class="s4">[</span><span class="s1">req</span><span class="s4">.</span><span class="s1">link</span><span class="s4">] = </span><span class="s1">req</span>

        <span class="s1">batch_download </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_batch_download</span><span class="s4">(</span>
            <span class="s1">links_to_fully_download</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">(),</span>
            <span class="s1">temp_dir</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s3">for </span><span class="s1">link</span><span class="s4">, (</span><span class="s1">filepath</span><span class="s4">, </span><span class="s1">_</span><span class="s4">) </span><span class="s3">in </span><span class="s1">batch_download</span><span class="s4">:</span>
            <span class="s1">logger</span><span class="s4">.</span><span class="s1">debug</span><span class="s4">(</span><span class="s6">&quot;Downloading link %s to %s&quot;</span><span class="s4">, </span><span class="s1">link</span><span class="s4">, </span><span class="s1">filepath</span><span class="s4">)</span>
            <span class="s1">req </span><span class="s4">= </span><span class="s1">links_to_fully_download</span><span class="s4">[</span><span class="s1">link</span><span class="s4">]</span>
            <span class="s1">req</span><span class="s4">.</span><span class="s1">local_file_path </span><span class="s4">= </span><span class="s1">filepath</span>
            <span class="s2"># TODO: This needs fixing for sdists</span>
            <span class="s2"># This is an emergency fix for #11847, which reports that</span>
            <span class="s2"># distributions get downloaded twice when metadata is loaded</span>
            <span class="s2"># from a PEP 658 standalone metadata file. Setting _downloaded</span>
            <span class="s2"># fixes this for wheels, but breaks the sdist case (tests</span>
            <span class="s2"># test_download_metadata). As PyPI is currently only serving</span>
            <span class="s2"># metadata for wheels, this is not an immediate issue.</span>
            <span class="s2"># Fixing the problem properly looks like it will require a</span>
            <span class="s2"># complete refactoring of the `prepare_linked_requirements_more`</span>
            <span class="s2"># logic, and I haven't a clue where to start on that, so for now</span>
            <span class="s2"># I have fixed the issue *just* for wheels.</span>
            <span class="s3">if </span><span class="s1">req</span><span class="s4">.</span><span class="s1">is_wheel</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_downloaded</span><span class="s4">[</span><span class="s1">req</span><span class="s4">.</span><span class="s1">link</span><span class="s4">.</span><span class="s1">url</span><span class="s4">] = </span><span class="s1">filepath</span>

        <span class="s2"># This step is necessary to ensure all lazy wheels are processed</span>
        <span class="s2"># successfully by the 'download', 'wheel', and 'install' commands.</span>
        <span class="s3">for </span><span class="s1">req </span><span class="s3">in </span><span class="s1">partially_downloaded_reqs</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_prepare_linked_requirement</span><span class="s4">(</span><span class="s1">req</span><span class="s4">, </span><span class="s1">parallel_builds</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">prepare_linked_requirement</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">req</span><span class="s4">: </span><span class="s1">InstallRequirement</span><span class="s4">, </span><span class="s1">parallel_builds</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s4">) </span><span class="s1">-&gt; BaseDistribution</span><span class="s4">:</span>
        <span class="s0">&quot;&quot;&quot;Prepare a requirement to be obtained from req.link.&quot;&quot;&quot;</span>
        <span class="s3">assert </span><span class="s1">req</span><span class="s4">.</span><span class="s1">link</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_log_preparing_link</span><span class="s4">(</span><span class="s1">req</span><span class="s4">)</span>
        <span class="s3">with </span><span class="s1">indent_log</span><span class="s4">():</span>
            <span class="s2"># Check if the relevant file is already available</span>
            <span class="s2"># in the download directory</span>
            <span class="s1">file_path </span><span class="s4">= </span><span class="s3">None</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">download_dir </span><span class="s3">is not None and </span><span class="s1">req</span><span class="s4">.</span><span class="s1">link</span><span class="s4">.</span><span class="s1">is_wheel</span><span class="s4">:</span>
                <span class="s1">hashes </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_linked_req_hashes</span><span class="s4">(</span><span class="s1">req</span><span class="s4">)</span>
                <span class="s1">file_path </span><span class="s4">= </span><span class="s1">_check_download_dir</span><span class="s4">(</span>
                    <span class="s1">req</span><span class="s4">.</span><span class="s1">link</span><span class="s4">,</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">download_dir</span><span class="s4">,</span>
                    <span class="s1">hashes</span><span class="s4">,</span>
                    <span class="s2"># When a locally built wheel has been found in cache, we don't warn</span>
                    <span class="s2"># about re-downloading when the already downloaded wheel hash does</span>
                    <span class="s2"># not match. This is because the hash must be checked against the</span>
                    <span class="s2"># original link, not the cached link. It that case the already</span>
                    <span class="s2"># downloaded file will be removed and re-fetched from cache (which</span>
                    <span class="s2"># implies a hash check against the cache entry's origin.json).</span>
                    <span class="s1">warn_on_hash_mismatch</span><span class="s4">=</span><span class="s3">not </span><span class="s1">req</span><span class="s4">.</span><span class="s1">is_wheel_from_cache</span><span class="s4">,</span>
                <span class="s4">)</span>

            <span class="s3">if </span><span class="s1">file_path </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s2"># The file is already available, so mark it as downloaded</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_downloaded</span><span class="s4">[</span><span class="s1">req</span><span class="s4">.</span><span class="s1">link</span><span class="s4">.</span><span class="s1">url</span><span class="s4">] = </span><span class="s1">file_path</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s2"># The file is not available, attempt to fetch only metadata</span>
                <span class="s1">metadata_dist </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_fetch_metadata_only</span><span class="s4">(</span><span class="s1">req</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">metadata_dist </span><span class="s3">is not None</span><span class="s4">:</span>
                    <span class="s1">req</span><span class="s4">.</span><span class="s1">needs_more_preparation </span><span class="s4">= </span><span class="s3">True</span>
                    <span class="s3">return </span><span class="s1">metadata_dist</span>

            <span class="s2"># None of the optimizations worked, fully prepare the requirement</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_prepare_linked_requirement</span><span class="s4">(</span><span class="s1">req</span><span class="s4">, </span><span class="s1">parallel_builds</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">prepare_linked_requirements_more</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">reqs</span><span class="s4">: </span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">InstallRequirement</span><span class="s4">], </span><span class="s1">parallel_builds</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s0">&quot;&quot;&quot;Prepare linked requirements more, if needed.&quot;&quot;&quot;</span>
        <span class="s1">reqs </span><span class="s4">= [</span><span class="s1">req </span><span class="s3">for </span><span class="s1">req </span><span class="s3">in </span><span class="s1">reqs </span><span class="s3">if </span><span class="s1">req</span><span class="s4">.</span><span class="s1">needs_more_preparation</span><span class="s4">]</span>
        <span class="s3">for </span><span class="s1">req </span><span class="s3">in </span><span class="s1">reqs</span><span class="s4">:</span>
            <span class="s2"># Determine if any of these requirements were already downloaded.</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">download_dir </span><span class="s3">is not None and </span><span class="s1">req</span><span class="s4">.</span><span class="s1">link</span><span class="s4">.</span><span class="s1">is_wheel</span><span class="s4">:</span>
                <span class="s1">hashes </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_linked_req_hashes</span><span class="s4">(</span><span class="s1">req</span><span class="s4">)</span>
                <span class="s1">file_path </span><span class="s4">= </span><span class="s1">_check_download_dir</span><span class="s4">(</span><span class="s1">req</span><span class="s4">.</span><span class="s1">link</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">download_dir</span><span class="s4">, </span><span class="s1">hashes</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">file_path </span><span class="s3">is not None</span><span class="s4">:</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">_downloaded</span><span class="s4">[</span><span class="s1">req</span><span class="s4">.</span><span class="s1">link</span><span class="s4">.</span><span class="s1">url</span><span class="s4">] = </span><span class="s1">file_path</span>
                    <span class="s1">req</span><span class="s4">.</span><span class="s1">needs_more_preparation </span><span class="s4">= </span><span class="s3">False</span>

        <span class="s2"># Prepare requirements we found were already downloaded for some</span>
        <span class="s2"># reason. The other downloads will be completed separately.</span>
        <span class="s1">partially_downloaded_reqs</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">InstallRequirement</span><span class="s4">] = []</span>
        <span class="s3">for </span><span class="s1">req </span><span class="s3">in </span><span class="s1">reqs</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">req</span><span class="s4">.</span><span class="s1">needs_more_preparation</span><span class="s4">:</span>
                <span class="s1">partially_downloaded_reqs</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">req</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_prepare_linked_requirement</span><span class="s4">(</span><span class="s1">req</span><span class="s4">, </span><span class="s1">parallel_builds</span><span class="s4">)</span>

        <span class="s2"># TODO: separate this part out from RequirementPreparer when the v1</span>
        <span class="s2"># resolver can be removed!</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_complete_partial_requirements</span><span class="s4">(</span>
            <span class="s1">partially_downloaded_reqs</span><span class="s4">,</span>
            <span class="s1">parallel_builds</span><span class="s4">=</span><span class="s1">parallel_builds</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_prepare_linked_requirement</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">req</span><span class="s4">: </span><span class="s1">InstallRequirement</span><span class="s4">, </span><span class="s1">parallel_builds</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s4">) </span><span class="s1">-&gt; BaseDistribution</span><span class="s4">:</span>
        <span class="s3">assert </span><span class="s1">req</span><span class="s4">.</span><span class="s1">link</span>
        <span class="s1">link </span><span class="s4">= </span><span class="s1">req</span><span class="s4">.</span><span class="s1">link</span>

        <span class="s1">hashes </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_linked_req_hashes</span><span class="s4">(</span><span class="s1">req</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">hashes </span><span class="s3">and </span><span class="s1">req</span><span class="s4">.</span><span class="s1">is_wheel_from_cache</span><span class="s4">:</span>
            <span class="s3">assert </span><span class="s1">req</span><span class="s4">.</span><span class="s1">download_info </span><span class="s3">is not None</span>
            <span class="s3">assert </span><span class="s1">link</span><span class="s4">.</span><span class="s1">is_wheel</span>
            <span class="s3">assert </span><span class="s1">link</span><span class="s4">.</span><span class="s1">is_file</span>
            <span class="s2"># We need to verify hashes, and we have found the requirement in the cache</span>
            <span class="s2"># of locally built wheels.</span>
            <span class="s3">if </span><span class="s4">(</span>
                <span class="s1">isinstance</span><span class="s4">(</span><span class="s1">req</span><span class="s4">.</span><span class="s1">download_info</span><span class="s4">.</span><span class="s1">info</span><span class="s4">, </span><span class="s1">ArchiveInfo</span><span class="s4">)</span>
                <span class="s3">and </span><span class="s1">req</span><span class="s4">.</span><span class="s1">download_info</span><span class="s4">.</span><span class="s1">info</span><span class="s4">.</span><span class="s1">hashes</span>
                <span class="s3">and </span><span class="s1">hashes</span><span class="s4">.</span><span class="s1">has_one_of</span><span class="s4">(</span><span class="s1">req</span><span class="s4">.</span><span class="s1">download_info</span><span class="s4">.</span><span class="s1">info</span><span class="s4">.</span><span class="s1">hashes</span><span class="s4">)</span>
            <span class="s4">):</span>
                <span class="s2"># At this point we know the requirement was built from a hashable source</span>
                <span class="s2"># artifact, and we verified that the cache entry's hash of the original</span>
                <span class="s2"># artifact matches one of the hashes we expect. We don't verify hashes</span>
                <span class="s2"># against the cached wheel, because the wheel is not the original.</span>
                <span class="s1">hashes </span><span class="s4">= </span><span class="s3">None</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">logger</span><span class="s4">.</span><span class="s1">warning</span><span class="s4">(</span>
                    <span class="s6">&quot;The hashes of the source archive found in cache entry &quot;</span>
                    <span class="s6">&quot;don't match, ignoring cached built wheel &quot;</span>
                    <span class="s6">&quot;and re-downloading source.&quot;</span>
                <span class="s4">)</span>
                <span class="s1">req</span><span class="s4">.</span><span class="s1">link </span><span class="s4">= </span><span class="s1">req</span><span class="s4">.</span><span class="s1">cached_wheel_source_link</span>
                <span class="s1">link </span><span class="s4">= </span><span class="s1">req</span><span class="s4">.</span><span class="s1">link</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_ensure_link_req_src_dir</span><span class="s4">(</span><span class="s1">req</span><span class="s4">, </span><span class="s1">parallel_builds</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">link</span><span class="s4">.</span><span class="s1">is_existing_dir</span><span class="s4">():</span>
            <span class="s1">local_file </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s3">elif </span><span class="s1">link</span><span class="s4">.</span><span class="s1">url </span><span class="s3">not in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_downloaded</span><span class="s4">:</span>
            <span class="s3">try</span><span class="s4">:</span>
                <span class="s1">local_file </span><span class="s4">= </span><span class="s1">unpack_url</span><span class="s4">(</span>
                    <span class="s1">link</span><span class="s4">,</span>
                    <span class="s1">req</span><span class="s4">.</span><span class="s1">source_dir</span><span class="s4">,</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">_download</span><span class="s4">,</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">verbosity</span><span class="s4">,</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">download_dir</span><span class="s4">,</span>
                    <span class="s1">hashes</span><span class="s4">,</span>
                <span class="s4">)</span>
            <span class="s3">except </span><span class="s1">NetworkConnectionError </span><span class="s3">as </span><span class="s1">exc</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">InstallationError</span><span class="s4">(</span>
                    <span class="s6">&quot;Could not install requirement {} because of HTTP &quot;</span>
                    <span class="s6">&quot;error {} for URL {}&quot;</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span><span class="s1">req</span><span class="s4">, </span><span class="s1">exc</span><span class="s4">, </span><span class="s1">link</span><span class="s4">)</span>
                <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">file_path </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_downloaded</span><span class="s4">[</span><span class="s1">link</span><span class="s4">.</span><span class="s1">url</span><span class="s4">]</span>
            <span class="s3">if </span><span class="s1">hashes</span><span class="s4">:</span>
                <span class="s1">hashes</span><span class="s4">.</span><span class="s1">check_against_path</span><span class="s4">(</span><span class="s1">file_path</span><span class="s4">)</span>
            <span class="s1">local_file </span><span class="s4">= </span><span class="s1">File</span><span class="s4">(</span><span class="s1">file_path</span><span class="s4">, </span><span class="s1">content_type</span><span class="s4">=</span><span class="s3">None</span><span class="s4">)</span>

        <span class="s2"># If download_info is set, we got it from the wheel cache.</span>
        <span class="s3">if </span><span class="s1">req</span><span class="s4">.</span><span class="s1">download_info </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s2"># Editables don't go through this function (see</span>
            <span class="s2"># prepare_editable_requirement).</span>
            <span class="s3">assert not </span><span class="s1">req</span><span class="s4">.</span><span class="s1">editable</span>
            <span class="s1">req</span><span class="s4">.</span><span class="s1">download_info </span><span class="s4">= </span><span class="s1">direct_url_from_link</span><span class="s4">(</span><span class="s1">link</span><span class="s4">, </span><span class="s1">req</span><span class="s4">.</span><span class="s1">source_dir</span><span class="s4">)</span>
            <span class="s2"># Make sure we have a hash in download_info. If we got it as part of the</span>
            <span class="s2"># URL, it will have been verified and we can rely on it. Otherwise we</span>
            <span class="s2"># compute it from the downloaded file.</span>
            <span class="s2"># FIXME: https://github.com/pypa/pip/issues/11943</span>
            <span class="s3">if </span><span class="s4">(</span>
                <span class="s1">isinstance</span><span class="s4">(</span><span class="s1">req</span><span class="s4">.</span><span class="s1">download_info</span><span class="s4">.</span><span class="s1">info</span><span class="s4">, </span><span class="s1">ArchiveInfo</span><span class="s4">)</span>
                <span class="s3">and not </span><span class="s1">req</span><span class="s4">.</span><span class="s1">download_info</span><span class="s4">.</span><span class="s1">info</span><span class="s4">.</span><span class="s1">hashes</span>
                <span class="s3">and </span><span class="s1">local_file</span>
            <span class="s4">):</span>
                <span class="s1">hash </span><span class="s4">= </span><span class="s1">hash_file</span><span class="s4">(</span><span class="s1">local_file</span><span class="s4">.</span><span class="s1">path</span><span class="s4">)[</span><span class="s5">0</span><span class="s4">].</span><span class="s1">hexdigest</span><span class="s4">()</span>
                <span class="s2"># We populate info.hash for backward compatibility.</span>
                <span class="s2"># This will automatically populate info.hashes.</span>
                <span class="s1">req</span><span class="s4">.</span><span class="s1">download_info</span><span class="s4">.</span><span class="s1">info</span><span class="s4">.</span><span class="s1">hash </span><span class="s4">= </span><span class="s6">f&quot;sha256=</span><span class="s3">{</span><span class="s1">hash</span><span class="s3">}</span><span class="s6">&quot;</span>

        <span class="s2"># For use in later processing,</span>
        <span class="s2"># preserve the file path on the requirement.</span>
        <span class="s3">if </span><span class="s1">local_file</span><span class="s4">:</span>
            <span class="s1">req</span><span class="s4">.</span><span class="s1">local_file_path </span><span class="s4">= </span><span class="s1">local_file</span><span class="s4">.</span><span class="s1">path</span>

        <span class="s1">dist </span><span class="s4">= </span><span class="s1">_get_prepared_distribution</span><span class="s4">(</span>
            <span class="s1">req</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">build_tracker</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">finder</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">build_isolation</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">check_build_deps</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">dist</span>

    <span class="s3">def </span><span class="s1">save_linked_requirement</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">req</span><span class="s4">: </span><span class="s1">InstallRequirement</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">assert </span><span class="s1">self</span><span class="s4">.</span><span class="s1">download_dir </span><span class="s3">is not None</span>
        <span class="s3">assert </span><span class="s1">req</span><span class="s4">.</span><span class="s1">link </span><span class="s3">is not None</span>
        <span class="s1">link </span><span class="s4">= </span><span class="s1">req</span><span class="s4">.</span><span class="s1">link</span>
        <span class="s3">if </span><span class="s1">link</span><span class="s4">.</span><span class="s1">is_vcs </span><span class="s3">or </span><span class="s4">(</span><span class="s1">link</span><span class="s4">.</span><span class="s1">is_existing_dir</span><span class="s4">() </span><span class="s3">and </span><span class="s1">req</span><span class="s4">.</span><span class="s1">editable</span><span class="s4">):</span>
            <span class="s2"># Make a .zip of the source_dir we already created.</span>
            <span class="s1">req</span><span class="s4">.</span><span class="s1">archive</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">download_dir</span><span class="s4">)</span>
            <span class="s3">return</span>

        <span class="s3">if </span><span class="s1">link</span><span class="s4">.</span><span class="s1">is_existing_dir</span><span class="s4">():</span>
            <span class="s1">logger</span><span class="s4">.</span><span class="s1">debug</span><span class="s4">(</span>
                <span class="s6">&quot;Not copying link to destination directory &quot;</span>
                <span class="s6">&quot;since it is a directory: %s&quot;</span><span class="s4">,</span>
                <span class="s1">link</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s3">return</span>
        <span class="s3">if </span><span class="s1">req</span><span class="s4">.</span><span class="s1">local_file_path </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s2"># No distribution was downloaded for this requirement.</span>
            <span class="s3">return</span>

        <span class="s1">download_location </span><span class="s4">= </span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">download_dir</span><span class="s4">, </span><span class="s1">link</span><span class="s4">.</span><span class="s1">filename</span><span class="s4">)</span>
        <span class="s3">if not </span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">exists</span><span class="s4">(</span><span class="s1">download_location</span><span class="s4">):</span>
            <span class="s1">shutil</span><span class="s4">.</span><span class="s1">copy</span><span class="s4">(</span><span class="s1">req</span><span class="s4">.</span><span class="s1">local_file_path</span><span class="s4">, </span><span class="s1">download_location</span><span class="s4">)</span>
            <span class="s1">download_path </span><span class="s4">= </span><span class="s1">display_path</span><span class="s4">(</span><span class="s1">download_location</span><span class="s4">)</span>
            <span class="s1">logger</span><span class="s4">.</span><span class="s1">info</span><span class="s4">(</span><span class="s6">&quot;Saved %s&quot;</span><span class="s4">, </span><span class="s1">download_path</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">prepare_editable_requirement</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">req</span><span class="s4">: </span><span class="s1">InstallRequirement</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; BaseDistribution</span><span class="s4">:</span>
        <span class="s0">&quot;&quot;&quot;Prepare an editable requirement.&quot;&quot;&quot;</span>
        <span class="s3">assert </span><span class="s1">req</span><span class="s4">.</span><span class="s1">editable</span><span class="s4">, </span><span class="s6">&quot;cannot prepare a non-editable req as editable&quot;</span>

        <span class="s1">logger</span><span class="s4">.</span><span class="s1">info</span><span class="s4">(</span><span class="s6">&quot;Obtaining %s&quot;</span><span class="s4">, </span><span class="s1">req</span><span class="s4">)</span>

        <span class="s3">with </span><span class="s1">indent_log</span><span class="s4">():</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">require_hashes</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">InstallationError</span><span class="s4">(</span>
                    <span class="s6">&quot;The editable requirement {} cannot be installed when &quot;</span>
                    <span class="s6">&quot;requiring hashes, because there is no single file to &quot;</span>
                    <span class="s6">&quot;hash.&quot;</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span><span class="s1">req</span><span class="s4">)</span>
                <span class="s4">)</span>
            <span class="s1">req</span><span class="s4">.</span><span class="s1">ensure_has_source_dir</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">src_dir</span><span class="s4">)</span>
            <span class="s1">req</span><span class="s4">.</span><span class="s1">update_editable</span><span class="s4">()</span>
            <span class="s3">assert </span><span class="s1">req</span><span class="s4">.</span><span class="s1">source_dir</span>
            <span class="s1">req</span><span class="s4">.</span><span class="s1">download_info </span><span class="s4">= </span><span class="s1">direct_url_for_editable</span><span class="s4">(</span><span class="s1">req</span><span class="s4">.</span><span class="s1">unpacked_source_directory</span><span class="s4">)</span>

            <span class="s1">dist </span><span class="s4">= </span><span class="s1">_get_prepared_distribution</span><span class="s4">(</span>
                <span class="s1">req</span><span class="s4">,</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">build_tracker</span><span class="s4">,</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">finder</span><span class="s4">,</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">build_isolation</span><span class="s4">,</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">check_build_deps</span><span class="s4">,</span>
            <span class="s4">)</span>

            <span class="s1">req</span><span class="s4">.</span><span class="s1">check_if_exists</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">use_user_site</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">dist</span>

    <span class="s3">def </span><span class="s1">prepare_installed_requirement</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">req</span><span class="s4">: </span><span class="s1">InstallRequirement</span><span class="s4">,</span>
        <span class="s1">skip_reason</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; BaseDistribution</span><span class="s4">:</span>
        <span class="s0">&quot;&quot;&quot;Prepare an already-installed requirement.&quot;&quot;&quot;</span>
        <span class="s3">assert </span><span class="s1">req</span><span class="s4">.</span><span class="s1">satisfied_by</span><span class="s4">, </span><span class="s6">&quot;req should have been satisfied but isn't&quot;</span>
        <span class="s3">assert </span><span class="s1">skip_reason </span><span class="s3">is not None</span><span class="s4">, (</span>
            <span class="s6">&quot;did not get skip reason skipped but req.satisfied_by &quot;</span>
            <span class="s6">&quot;is set to {}&quot;</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span><span class="s1">req</span><span class="s4">.</span><span class="s1">satisfied_by</span><span class="s4">)</span>
        <span class="s4">)</span>
        <span class="s1">logger</span><span class="s4">.</span><span class="s1">info</span><span class="s4">(</span>
            <span class="s6">&quot;Requirement %s: %s (%s)&quot;</span><span class="s4">, </span><span class="s1">skip_reason</span><span class="s4">, </span><span class="s1">req</span><span class="s4">, </span><span class="s1">req</span><span class="s4">.</span><span class="s1">satisfied_by</span><span class="s4">.</span><span class="s1">version</span>
        <span class="s4">)</span>
        <span class="s3">with </span><span class="s1">indent_log</span><span class="s4">():</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">require_hashes</span><span class="s4">:</span>
                <span class="s1">logger</span><span class="s4">.</span><span class="s1">debug</span><span class="s4">(</span>
                    <span class="s6">&quot;Since it is already installed, we are trusting this &quot;</span>
                    <span class="s6">&quot;package without checking its hash. To ensure a &quot;</span>
                    <span class="s6">&quot;completely repeatable environment, install into an &quot;</span>
                    <span class="s6">&quot;empty virtualenv.&quot;</span>
                <span class="s4">)</span>
            <span class="s3">return </span><span class="s1">InstalledDistribution</span><span class="s4">(</span><span class="s1">req</span><span class="s4">).</span><span class="s1">get_metadata_distribution</span><span class="s4">()</span>
</pre>
</body>
</html>